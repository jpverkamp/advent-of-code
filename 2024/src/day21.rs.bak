use std::{cell::RefCell, rc::Rc};

use aoc_runner_derive::{aoc, aoc_generator};
use pathfinding::prelude::astar;

use crate::{Direction, Point};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct Keyboard {
    width: usize,
    height: usize,
    keys: Vec<Option<char>>,
}

impl From<&str> for Keyboard {
    fn from(value: &str) -> Self {
        let mut width = 0;
        let mut height = 0;
        let mut keys = Vec::new();

        for line in value.lines() {
            if line.is_empty() {
                continue;
            }

            height += 1;
            width = width.max(line.len());

            for c in line.chars() {
                if c.is_whitespace() {
                    continue;
                } else if c == '*' {
                    keys.push(None);
                } else {
                    keys.push(Some(c));
                }
            }
        }

        Self {
            width,
            height,
            keys,
        }
    }
}

impl Keyboard {
    fn get_key(&self, p: Point) -> Option<char> {
        if p.x < 0 || p.y < 0 || p.x >= self.width as i32 || p.y >= self.height as i32 {
            None
        } else {
            self.keys[p.y as usize * self.width + p.x as usize]
        }
    }

    fn get_point(&self, key: char) -> Option<Point> {
        for x in 0..self.width {
            for y in 0..self.height {
                let p: Point = (x, y).into();
                if self.get_key(p) == Some(key) {
                    return Some(p);
                }
            }
        }

        None
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
struct Typer<'kb> {
    keyboard: &'kb Keyboard,
    p: Point,
}

impl<'kb> Typer<'kb> {
    fn new(keyboard: &'kb Keyboard) -> Self {
        for x in 0..keyboard.width {
            for y in 0..keyboard.height {
                let p: Point = (x, y).into();
                if keyboard.get_key(p) == Some('A') {
                    return Self { keyboard, p };
                }
            }
        }

        panic!("keyboard does not contain 'A'");
    }

    fn go(&mut self, c: char) -> bool {
        self.p = self.p
            + match c {
                '^' => Direction::Up,
                'v' => Direction::Down,
                '<' => Direction::Left,
                '>' => Direction::Right,
                _ => {
                    return false;
                }
            };

        true
    }

    fn type_char_path(&mut self, target: char) -> String {
        let target_p = match self.keyboard.get_point(target) {
            Some(p) => p,
            None => panic!("could not find target"),
        };

        match astar(
            &(self.p, None),
            |&(p, _)| {
                let mut neighbors = Vec::new();

                Direction::all().into_iter().for_each(|d| {
                    if let Some(c) = self.keyboard.get_key(p + d) {
                        neighbors.push(((p + d, Some(d)), 1));
                    }
                });

                neighbors
            },
            |&(p, _)| p.manhattan_distance(&target_p),
            |&(p, _)| self.keyboard.get_key(p) == Some(target),
        ) {
            Some((path, _)) => {
                let &(last_p, _) = path.last().unwrap();
                self.p = last_p;

                path.iter()
                    .filter_map(|&(_, d)| match d {
                        Some(Direction::Up) => Some('^'),
                        Some(Direction::Down) => Some('v'),
                        Some(Direction::Left) => Some('<'),
                        Some(Direction::Right) => Some('>'),
                        _ => None,
                    })
                    .chain(std::iter::once('A'))
                    .collect()
            }
            None => panic!("could not find path to target"),
        }
    }

    fn type_string_path(&mut self, target: &str) -> String {
        target.chars().map(|c| self.type_char_path(c)).collect()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct TyperChain<'kbs> {
    me: Typer<'kbs>,
    next: Option<Rc<RefCell<TyperChain<'kbs>>>>,
}

impl<'kbs> std::hash::Hash for TyperChain<'kbs> {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.me.hash(state);
        if let Some(ref next) = self.next {
            next.borrow().hash(state);
        }
    }
}

impl<'kbs> TyperChain<'kbs> {
    fn new(keyboards: &'kbs [Keyboard]) -> Self {
        let me = Typer::new(&keyboards[0]);
        let next = if keyboards.len() > 1 {
            Some(Rc::new(RefCell::new(TyperChain::new(&keyboards[1..]))))
        } else {
            None
        };

        Self { me, next }
    }

    // Type a single char on this chain
    fn type_char(&mut self, c: char) -> Result<Option<char>, ()> {
        if c == 'A' {
            // An A sends activates the next robot in line
            // If there is none, return the A
            // This may recursively fail
            if let Some(next) = &self.next {
                return next.borrow_mut().type_char(c);
            } else {
                return Ok(Some('A'));
            }
        } else {
            // Any other character just updates this robot
            // If there is no next robot in line, it also emits the character
            // If we fail to move, that is our error case
            if self.me.go(c) {
                if self.next.is_none() {
                    return Ok(Some(self.me.keyboard.get_key(self.me.p).unwrap()));
                } else {
                    return Ok(None);
                }
            } else {
                Err(())
            }
        }
    }
}

#[aoc_generator(day21)]
fn parse(input: &str) -> String {
    input.to_string()
}

#[aoc(day21, part1, v1)]
fn part1_v1<'kbs>(input: &str) -> String {
    let keypad = Keyboard::from(
        "
789
456
123
*0A",
    );

    let arrows = Keyboard::from(
        "
*^A
<v>",
    );

    // let keyboards = vec![keypad.clone(), arrows.clone(), arrows.clone()];
    let keyboards = vec![keypad.clone()];
    let initial_chain = TyperChain::new(keyboards.leak());

    for line in input.lines() {
        println!("== {} ==", line);

        // State is the 3 robots + the index into the final string
        type State<'a, 'kbs> = (TyperChain<'kbs>, usize);
        const KEYS: [char; 5] = ['^', '<', '>', 'v', 'A'];
        let target_chars = line.chars().collect::<Vec<_>>();

        let successors = |(chain, index): &State<'_, 'kbs>| {
            let mut next = vec![];

            // println!("successor({:?}, {})", chain, index);

            for c in KEYS {
                let mut new_chain = chain.clone();
                match new_chain.type_char(c) {
                    Ok(Some(c)) => {
                        // If we typed the correct next char, continue
                        // If we typed something else, this is an invalid branch
                        if c == target_chars[*index] {
                            next.push(((new_chain, index + 1), 1));
                        } else {
                            continue;
                        }
                    }
                    Ok(None) => {
                        // Advanced but did not type anything
                        next.push(((new_chain, *index), 1));
                    }
                    Err(()) => {
                        // Failed to advance somewhere along the line, this is an invalid branch
                        continue;
                    }
                }
            }

            next
        };

        match astar(
            &(initial_chain.clone(), 0),
            successors,
            |(_, i)| {
                // TODO: Can we make this better?
                target_chars.len() - i
            },
            |(_, i)| *i == target_chars.len(),
        ) {
            Some((path, _)) => {
                println!("path: {:?}", path);
                println!("len: {}", path.len());
            }
            None => {
                println!("no path");
            }
        }
    }
    
    todo!()
}

#[aoc(day21, part2, v1)]
fn part2_v1(input: &str) -> String {
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::make_test;

    const EXAMPLE: &str = "\
029A
980A
179A
456A
379A";

    make_test!([part1_v1] => "day21.txt", 126384, "final output");
    make_test!([part2_v1] => "day21.txt", "example output", "final output");
}
